/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 0.46.0-beta
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ApiErrorBadRequest;
import org.openapitools.client.model.ApiErrorNotFound;
import org.openapitools.client.model.ApiErrorUnauthorized;
import org.openapitools.client.model.ApiErrorUnprocessableEntity;
import org.openapitools.client.model.Currency;
import org.openapitools.client.model.Fee;
import org.openapitools.client.model.FeeUpdateInput;
import org.openapitools.client.model.FeesPaginated;
import java.time.OffsetDateTime;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FeesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FeesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public FeesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for findAllFees
     * @param page Page number. (optional)
     * @param perPage Number of records per page. (optional)
     * @param externalCustomerId Unique identifier assigned to the customer in your application. (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Filter results by feeâ€™s currency. (optional)
     * @param feeType The fee type. Possible values are &#x60;add-on&#x60;, &#x60;charge&#x60;, &#x60;credit&#x60; or &#x60;subscription&#x60;. (optional)
     * @param billableMetricCode Filter results by the &#x60;code&#x60; of the billable metric attached to the fee. Only applies to &#x60;charge&#x60; types. (optional)
     * @param paymentStatus Indicates the payment status of the fee. It represents the current status of the payment associated with the fee. The possible values for this field are &#x60;pending&#x60;, &#x60;succeeded&#x60;, &#x60;failed&#x60; and refunded&#x60;. (optional)
     * @param createdAtFrom Filter results created after creation date and time in UTC. (optional)
     * @param createdAtTo Filter results created before creation date and time in UTC. (optional)
     * @param succeededAtFrom Filter results with payment success after creation date and time in UTC. (optional)
     * @param succeededAtTo Filter results with payment success after creation date and time in UTC. (optional)
     * @param failedAtFrom Filter results with payment failure after creation date and time in UTC. (optional)
     * @param failedAtTo Filter results with payment failure after creation date and time in UTC. (optional)
     * @param refundedAtFrom Filter results with payment refund after creation date and time in UTC. (optional)
     * @param refundedAtTo Filter results with payment refund after creation date and time in UTC. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findAllFeesCall(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, Currency currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fees";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (externalCustomerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("external_customer_id", externalCustomerId));
        }

        if (externalSubscriptionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("external_subscription_id", externalSubscriptionId));
        }

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (feeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fee_type", feeType));
        }

        if (billableMetricCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("billable_metric_code", billableMetricCode));
        }

        if (paymentStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("payment_status", paymentStatus));
        }

        if (createdAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_at_from", createdAtFrom));
        }

        if (createdAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_at_to", createdAtTo));
        }

        if (succeededAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("succeeded_at_from", succeededAtFrom));
        }

        if (succeededAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("succeeded_at_to", succeededAtTo));
        }

        if (failedAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("failed_at_from", failedAtFrom));
        }

        if (failedAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("failed_at_to", failedAtTo));
        }

        if (refundedAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("refunded_at_from", refundedAtFrom));
        }

        if (refundedAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("refunded_at_to", refundedAtTo));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findAllFeesValidateBeforeCall(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, Currency currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo, final ApiCallback _callback) throws ApiException {
        return findAllFeesCall(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo, _callback);

    }

    /**
     * List all fees
     * This endpoint is used for retrieving all fees that has been issued.
     * @param page Page number. (optional)
     * @param perPage Number of records per page. (optional)
     * @param externalCustomerId Unique identifier assigned to the customer in your application. (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Filter results by feeâ€™s currency. (optional)
     * @param feeType The fee type. Possible values are &#x60;add-on&#x60;, &#x60;charge&#x60;, &#x60;credit&#x60; or &#x60;subscription&#x60;. (optional)
     * @param billableMetricCode Filter results by the &#x60;code&#x60; of the billable metric attached to the fee. Only applies to &#x60;charge&#x60; types. (optional)
     * @param paymentStatus Indicates the payment status of the fee. It represents the current status of the payment associated with the fee. The possible values for this field are &#x60;pending&#x60;, &#x60;succeeded&#x60;, &#x60;failed&#x60; and refunded&#x60;. (optional)
     * @param createdAtFrom Filter results created after creation date and time in UTC. (optional)
     * @param createdAtTo Filter results created before creation date and time in UTC. (optional)
     * @param succeededAtFrom Filter results with payment success after creation date and time in UTC. (optional)
     * @param succeededAtTo Filter results with payment success after creation date and time in UTC. (optional)
     * @param failedAtFrom Filter results with payment failure after creation date and time in UTC. (optional)
     * @param failedAtTo Filter results with payment failure after creation date and time in UTC. (optional)
     * @param refundedAtFrom Filter results with payment refund after creation date and time in UTC. (optional)
     * @param refundedAtTo Filter results with payment refund after creation date and time in UTC. (optional)
     * @return FeesPaginated
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public FeesPaginated findAllFees(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, Currency currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo) throws ApiException {
        ApiResponse<FeesPaginated> localVarResp = findAllFeesWithHttpInfo(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo);
        return localVarResp.getData();
    }

    /**
     * List all fees
     * This endpoint is used for retrieving all fees that has been issued.
     * @param page Page number. (optional)
     * @param perPage Number of records per page. (optional)
     * @param externalCustomerId Unique identifier assigned to the customer in your application. (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Filter results by feeâ€™s currency. (optional)
     * @param feeType The fee type. Possible values are &#x60;add-on&#x60;, &#x60;charge&#x60;, &#x60;credit&#x60; or &#x60;subscription&#x60;. (optional)
     * @param billableMetricCode Filter results by the &#x60;code&#x60; of the billable metric attached to the fee. Only applies to &#x60;charge&#x60; types. (optional)
     * @param paymentStatus Indicates the payment status of the fee. It represents the current status of the payment associated with the fee. The possible values for this field are &#x60;pending&#x60;, &#x60;succeeded&#x60;, &#x60;failed&#x60; and refunded&#x60;. (optional)
     * @param createdAtFrom Filter results created after creation date and time in UTC. (optional)
     * @param createdAtTo Filter results created before creation date and time in UTC. (optional)
     * @param succeededAtFrom Filter results with payment success after creation date and time in UTC. (optional)
     * @param succeededAtTo Filter results with payment success after creation date and time in UTC. (optional)
     * @param failedAtFrom Filter results with payment failure after creation date and time in UTC. (optional)
     * @param failedAtTo Filter results with payment failure after creation date and time in UTC. (optional)
     * @param refundedAtFrom Filter results with payment refund after creation date and time in UTC. (optional)
     * @param refundedAtTo Filter results with payment refund after creation date and time in UTC. (optional)
     * @return ApiResponse&lt;FeesPaginated&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FeesPaginated> findAllFeesWithHttpInfo(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, Currency currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo) throws ApiException {
        okhttp3.Call localVarCall = findAllFeesValidateBeforeCall(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo, null);
        Type localVarReturnType = new TypeToken<FeesPaginated>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all fees (asynchronously)
     * This endpoint is used for retrieving all fees that has been issued.
     * @param page Page number. (optional)
     * @param perPage Number of records per page. (optional)
     * @param externalCustomerId Unique identifier assigned to the customer in your application. (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Filter results by feeâ€™s currency. (optional)
     * @param feeType The fee type. Possible values are &#x60;add-on&#x60;, &#x60;charge&#x60;, &#x60;credit&#x60; or &#x60;subscription&#x60;. (optional)
     * @param billableMetricCode Filter results by the &#x60;code&#x60; of the billable metric attached to the fee. Only applies to &#x60;charge&#x60; types. (optional)
     * @param paymentStatus Indicates the payment status of the fee. It represents the current status of the payment associated with the fee. The possible values for this field are &#x60;pending&#x60;, &#x60;succeeded&#x60;, &#x60;failed&#x60; and refunded&#x60;. (optional)
     * @param createdAtFrom Filter results created after creation date and time in UTC. (optional)
     * @param createdAtTo Filter results created before creation date and time in UTC. (optional)
     * @param succeededAtFrom Filter results with payment success after creation date and time in UTC. (optional)
     * @param succeededAtTo Filter results with payment success after creation date and time in UTC. (optional)
     * @param failedAtFrom Filter results with payment failure after creation date and time in UTC. (optional)
     * @param failedAtTo Filter results with payment failure after creation date and time in UTC. (optional)
     * @param refundedAtFrom Filter results with payment refund after creation date and time in UTC. (optional)
     * @param refundedAtTo Filter results with payment refund after creation date and time in UTC. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findAllFeesAsync(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, Currency currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo, final ApiCallback<FeesPaginated> _callback) throws ApiException {

        okhttp3.Call localVarCall = findAllFeesValidateBeforeCall(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo, _callback);
        Type localVarReturnType = new TypeToken<FeesPaginated>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findFee
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findFeeCall(UUID lagoId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fees/{lago_id}"
            .replace("{" + "lago_id" + "}", localVarApiClient.escapeString(lagoId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findFeeValidateBeforeCall(UUID lagoId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'lagoId' is set
        if (lagoId == null) {
            throw new ApiException("Missing the required parameter 'lagoId' when calling findFee(Async)");
        }

        return findFeeCall(lagoId, _callback);

    }

    /**
     * Retrieve a specific fee
     * This endpoint is used for retrieving a specific fee that has been issued.
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @return Fee
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public Fee findFee(UUID lagoId) throws ApiException {
        ApiResponse<Fee> localVarResp = findFeeWithHttpInfo(lagoId);
        return localVarResp.getData();
    }

    /**
     * Retrieve a specific fee
     * This endpoint is used for retrieving a specific fee that has been issued.
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @return ApiResponse&lt;Fee&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Fee> findFeeWithHttpInfo(UUID lagoId) throws ApiException {
        okhttp3.Call localVarCall = findFeeValidateBeforeCall(lagoId, null);
        Type localVarReturnType = new TypeToken<Fee>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a specific fee (asynchronously)
     * This endpoint is used for retrieving a specific fee that has been issued.
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findFeeAsync(UUID lagoId, final ApiCallback<Fee> _callback) throws ApiException {

        okhttp3.Call localVarCall = findFeeValidateBeforeCall(lagoId, _callback);
        Type localVarReturnType = new TypeToken<Fee>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateFee
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @param feeUpdateInput Fee payload (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateFeeCall(UUID lagoId, FeeUpdateInput feeUpdateInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = feeUpdateInput;

        // create path and map variables
        String localVarPath = "/fees/{lago_id}"
            .replace("{" + "lago_id" + "}", localVarApiClient.escapeString(lagoId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateFeeValidateBeforeCall(UUID lagoId, FeeUpdateInput feeUpdateInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'lagoId' is set
        if (lagoId == null) {
            throw new ApiException("Missing the required parameter 'lagoId' when calling updateFee(Async)");
        }

        return updateFeeCall(lagoId, feeUpdateInput, _callback);

    }

    /**
     * Update a fee
     * This endpoint is used for updating a specific fee that has been issued.
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @param feeUpdateInput Fee payload (optional)
     * @return Fee
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public Fee updateFee(UUID lagoId, FeeUpdateInput feeUpdateInput) throws ApiException {
        ApiResponse<Fee> localVarResp = updateFeeWithHttpInfo(lagoId, feeUpdateInput);
        return localVarResp.getData();
    }

    /**
     * Update a fee
     * This endpoint is used for updating a specific fee that has been issued.
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @param feeUpdateInput Fee payload (optional)
     * @return ApiResponse&lt;Fee&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Fee> updateFeeWithHttpInfo(UUID lagoId, FeeUpdateInput feeUpdateInput) throws ApiException {
        okhttp3.Call localVarCall = updateFeeValidateBeforeCall(lagoId, feeUpdateInput, null);
        Type localVarReturnType = new TypeToken<Fee>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a fee (asynchronously)
     * This endpoint is used for updating a specific fee that has been issued.
     * @param lagoId Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system. (required)
     * @param feeUpdateInput Fee payload (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Fee updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateFeeAsync(UUID lagoId, FeeUpdateInput feeUpdateInput, final ApiCallback<Fee> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateFeeValidateBeforeCall(lagoId, feeUpdateInput, _callback);
        Type localVarReturnType = new TypeToken<Fee>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
