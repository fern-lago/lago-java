/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 0.46.0-beta
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import org.openapitools.client.model.Currency;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * WalletCreateInputWallet
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-08-31T09:24:39.843670Z[Etc/UTC]")
public class WalletCreateInputWallet {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RATE_AMOUNT = "rate_amount";
  @SerializedName(SERIALIZED_NAME_RATE_AMOUNT)
  private String rateAmount;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private Currency currency;

  public static final String SERIALIZED_NAME_PAID_CREDITS = "paid_credits";
  @SerializedName(SERIALIZED_NAME_PAID_CREDITS)
  private String paidCredits;

  public static final String SERIALIZED_NAME_GRANTED_CREDITS = "granted_credits";
  @SerializedName(SERIALIZED_NAME_GRANTED_CREDITS)
  private String grantedCredits;

  public static final String SERIALIZED_NAME_EXTERNAL_CUSTOMER_ID = "external_customer_id";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_CUSTOMER_ID)
  private String externalCustomerId;

  public static final String SERIALIZED_NAME_EXPIRATION_AT = "expiration_at";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_AT)
  private OffsetDateTime expirationAt;

  public WalletCreateInputWallet() {
  }

  public WalletCreateInputWallet name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name of the wallet.
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public WalletCreateInputWallet rateAmount(String rateAmount) {
    
    this.rateAmount = rateAmount;
    return this;
  }

   /**
   * The rate of conversion between credits and the amount in the specified currency. It indicates the ratio or factor used to convert credits into the corresponding monetary value in the currency of the transaction.
   * @return rateAmount
  **/
  @javax.annotation.Nonnull
  public String getRateAmount() {
    return rateAmount;
  }


  public void setRateAmount(String rateAmount) {
    this.rateAmount = rateAmount;
  }


  public WalletCreateInputWallet currency(Currency currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * Get currency
   * @return currency
  **/
  @javax.annotation.Nonnull
  public Currency getCurrency() {
    return currency;
  }


  public void setCurrency(Currency currency) {
    this.currency = currency;
  }


  public WalletCreateInputWallet paidCredits(String paidCredits) {
    
    this.paidCredits = paidCredits;
    return this;
  }

   /**
   * The number of paid credits. Required only if there is no granted credits.
   * @return paidCredits
  **/
  @javax.annotation.Nullable
  public String getPaidCredits() {
    return paidCredits;
  }


  public void setPaidCredits(String paidCredits) {
    this.paidCredits = paidCredits;
  }


  public WalletCreateInputWallet grantedCredits(String grantedCredits) {
    
    this.grantedCredits = grantedCredits;
    return this;
  }

   /**
   * The number of free granted credits. Required only if there is no paid credits.
   * @return grantedCredits
  **/
  @javax.annotation.Nullable
  public String getGrantedCredits() {
    return grantedCredits;
  }


  public void setGrantedCredits(String grantedCredits) {
    this.grantedCredits = grantedCredits;
  }


  public WalletCreateInputWallet externalCustomerId(String externalCustomerId) {
    
    this.externalCustomerId = externalCustomerId;
    return this;
  }

   /**
   * The customer external unique identifier (provided by your own application)
   * @return externalCustomerId
  **/
  @javax.annotation.Nonnull
  public String getExternalCustomerId() {
    return externalCustomerId;
  }


  public void setExternalCustomerId(String externalCustomerId) {
    this.externalCustomerId = externalCustomerId;
  }


  public WalletCreateInputWallet expirationAt(OffsetDateTime expirationAt) {
    
    this.expirationAt = expirationAt;
    return this;
  }

   /**
   * The date and time that determines when the wallet will expire. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).
   * @return expirationAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getExpirationAt() {
    return expirationAt;
  }


  public void setExpirationAt(OffsetDateTime expirationAt) {
    this.expirationAt = expirationAt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WalletCreateInputWallet walletCreateInputWallet = (WalletCreateInputWallet) o;
    return Objects.equals(this.name, walletCreateInputWallet.name) &&
        Objects.equals(this.rateAmount, walletCreateInputWallet.rateAmount) &&
        Objects.equals(this.currency, walletCreateInputWallet.currency) &&
        Objects.equals(this.paidCredits, walletCreateInputWallet.paidCredits) &&
        Objects.equals(this.grantedCredits, walletCreateInputWallet.grantedCredits) &&
        Objects.equals(this.externalCustomerId, walletCreateInputWallet.externalCustomerId) &&
        Objects.equals(this.expirationAt, walletCreateInputWallet.expirationAt);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, rateAmount, currency, paidCredits, grantedCredits, externalCustomerId, expirationAt);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WalletCreateInputWallet {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    rateAmount: ").append(toIndentedString(rateAmount)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    paidCredits: ").append(toIndentedString(paidCredits)).append("\n");
    sb.append("    grantedCredits: ").append(toIndentedString(grantedCredits)).append("\n");
    sb.append("    externalCustomerId: ").append(toIndentedString(externalCustomerId)).append("\n");
    sb.append("    expirationAt: ").append(toIndentedString(expirationAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("rate_amount");
    openapiFields.add("currency");
    openapiFields.add("paid_credits");
    openapiFields.add("granted_credits");
    openapiFields.add("external_customer_id");
    openapiFields.add("expiration_at");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("rate_amount");
    openapiRequiredFields.add("currency");
    openapiRequiredFields.add("external_customer_id");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to WalletCreateInputWallet
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WalletCreateInputWallet.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WalletCreateInputWallet is not found in the empty JSON string", WalletCreateInputWallet.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!WalletCreateInputWallet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WalletCreateInputWallet` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : WalletCreateInputWallet.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("rate_amount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rate_amount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rate_amount").toString()));
      }
      // validate the required field `currency`
      Currency.validateJsonElement(jsonObj.get("currency"));
      if ((jsonObj.get("paid_credits") != null && !jsonObj.get("paid_credits").isJsonNull()) && !jsonObj.get("paid_credits").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paid_credits` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paid_credits").toString()));
      }
      if ((jsonObj.get("granted_credits") != null && !jsonObj.get("granted_credits").isJsonNull()) && !jsonObj.get("granted_credits").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `granted_credits` to be a primitive type in the JSON string but got `%s`", jsonObj.get("granted_credits").toString()));
      }
      if (!jsonObj.get("external_customer_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `external_customer_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("external_customer_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WalletCreateInputWallet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WalletCreateInputWallet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WalletCreateInputWallet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WalletCreateInputWallet.class));

       return (TypeAdapter<T>) new TypeAdapter<WalletCreateInputWallet>() {
           @Override
           public void write(JsonWriter out, WalletCreateInputWallet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WalletCreateInputWallet read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of WalletCreateInputWallet given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of WalletCreateInputWallet
  * @throws IOException if the JSON string is invalid with respect to WalletCreateInputWallet
  */
  public static WalletCreateInputWallet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WalletCreateInputWallet.class);
  }

 /**
  * Convert an instance of WalletCreateInputWallet to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

