/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 0.46.0-beta
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-08-31T09:24:39.843670Z[Etc/UTC]")
public class CustomerBillingConfiguration {
  public static final String SERIALIZED_NAME_INVOICE_GRACE_PERIOD = "invoice_grace_period";
  @SerializedName(SERIALIZED_NAME_INVOICE_GRACE_PERIOD)
  private Integer invoiceGracePeriod;

  /**
   * The payment provider utilized to initiate payments for invoices issued by Lago. Accepted values: &#x60;stripe&#x60;, &#x60;adyen&#x60;, &#x60;gocardless&#x60; or null. This field is required if you intend to assign a &#x60;provider_customer_id&#x60;.
   */
  @JsonAdapter(PaymentProviderEnum.Adapter.class)
  public enum PaymentProviderEnum {
    STRIPE("stripe"),
    
    ADYEN("adyen"),
    
    GOCARDLESS("gocardless");

    private String value;

    PaymentProviderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PaymentProviderEnum fromValue(String value) {
      for (PaymentProviderEnum b : PaymentProviderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PaymentProviderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PaymentProviderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PaymentProviderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PaymentProviderEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PAYMENT_PROVIDER = "payment_provider";
  @SerializedName(SERIALIZED_NAME_PAYMENT_PROVIDER)
  private PaymentProviderEnum paymentProvider;

  public static final String SERIALIZED_NAME_PROVIDER_CUSTOMER_ID = "provider_customer_id";
  @SerializedName(SERIALIZED_NAME_PROVIDER_CUSTOMER_ID)
  private String providerCustomerId;

  public static final String SERIALIZED_NAME_SYNC = "sync";
  @SerializedName(SERIALIZED_NAME_SYNC)
  private Boolean sync;

  public static final String SERIALIZED_NAME_SYNC_WITH_PROVIDER = "sync_with_provider";
  @SerializedName(SERIALIZED_NAME_SYNC_WITH_PROVIDER)
  private Boolean syncWithProvider;

  public static final String SERIALIZED_NAME_DOCUMENT_LOCALE = "document_locale";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_LOCALE)
  private String documentLocale;

  public static final String SERIALIZED_NAME_PROVIDER_PAYMENT_METHODS = "provider_payment_methods";
  @SerializedName(SERIALIZED_NAME_PROVIDER_PAYMENT_METHODS)
  private List<String> providerPaymentMethods;

  public CustomerBillingConfiguration() {
  }

  public CustomerBillingConfiguration invoiceGracePeriod(Integer invoiceGracePeriod) {
    
    this.invoiceGracePeriod = invoiceGracePeriod;
    return this;
  }

   /**
   * The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items
   * @return invoiceGracePeriod
  **/
  @javax.annotation.Nullable
  public Integer getInvoiceGracePeriod() {
    return invoiceGracePeriod;
  }


  public void setInvoiceGracePeriod(Integer invoiceGracePeriod) {
    this.invoiceGracePeriod = invoiceGracePeriod;
  }


  public CustomerBillingConfiguration paymentProvider(PaymentProviderEnum paymentProvider) {
    
    this.paymentProvider = paymentProvider;
    return this;
  }

   /**
   * The payment provider utilized to initiate payments for invoices issued by Lago. Accepted values: &#x60;stripe&#x60;, &#x60;adyen&#x60;, &#x60;gocardless&#x60; or null. This field is required if you intend to assign a &#x60;provider_customer_id&#x60;.
   * @return paymentProvider
  **/
  @javax.annotation.Nullable
  public PaymentProviderEnum getPaymentProvider() {
    return paymentProvider;
  }


  public void setPaymentProvider(PaymentProviderEnum paymentProvider) {
    this.paymentProvider = paymentProvider;
  }


  public CustomerBillingConfiguration providerCustomerId(String providerCustomerId) {
    
    this.providerCustomerId = providerCustomerId;
    return this;
  }

   /**
   * The customer ID within the payment provider&#39;s system. If this field is not provided, Lago has the option to create a new customer record within the payment provider&#39;s system on behalf of the customer
   * @return providerCustomerId
  **/
  @javax.annotation.Nullable
  public String getProviderCustomerId() {
    return providerCustomerId;
  }


  public void setProviderCustomerId(String providerCustomerId) {
    this.providerCustomerId = providerCustomerId;
  }


  public CustomerBillingConfiguration sync(Boolean sync) {
    
    this.sync = sync;
    return this;
  }

   /**
   * Set this field to &#x60;true&#x60; if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the &#x60;provider_customer_id&#x60; is &#x60;null&#x60; and the customer is automatically created in the payment provider through Lago. By default, the value is set to &#x60;false&#x60;
   * @return sync
  **/
  @javax.annotation.Nullable
  public Boolean getSync() {
    return sync;
  }


  public void setSync(Boolean sync) {
    this.sync = sync;
  }


  public CustomerBillingConfiguration syncWithProvider(Boolean syncWithProvider) {
    
    this.syncWithProvider = syncWithProvider;
    return this;
  }

   /**
   * Set this field to &#x60;true&#x60; if you want to create a customer record in the payment provider&#39;s system. This option is applicable only when the &#x60;provider_customer_id&#x60; is null and the &#x60;sync_with_provider&#x60; field is set to &#x60;true&#x60;. By default, the value is set to &#x60;false&#x60;
   * @return syncWithProvider
  **/
  @javax.annotation.Nullable
  public Boolean getSyncWithProvider() {
    return syncWithProvider;
  }


  public void setSyncWithProvider(Boolean syncWithProvider) {
    this.syncWithProvider = syncWithProvider;
  }


  public CustomerBillingConfiguration documentLocale(String documentLocale) {
    
    this.documentLocale = documentLocale;
    return this;
  }

   /**
   * The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago
   * @return documentLocale
  **/
  @javax.annotation.Nullable
  public String getDocumentLocale() {
    return documentLocale;
  }


  public void setDocumentLocale(String documentLocale) {
    this.documentLocale = documentLocale;
  }


  public CustomerBillingConfiguration providerPaymentMethods(List<String> providerPaymentMethods) {
    
    this.providerPaymentMethods = providerPaymentMethods;
    return this;
  }

  public CustomerBillingConfiguration addProviderPaymentMethodsItem(String providerPaymentMethodsItem) {
    if (this.providerPaymentMethods == null) {
      this.providerPaymentMethods = new ArrayList<>();
    }
    this.providerPaymentMethods.add(providerPaymentMethodsItem);
    return this;
  }

   /**
   * Specifies the available payment methods that can be used for this customer when &#x60;payment_provider&#x60; is set to &#x60;stripe&#x60;. The &#x60;provider_payment_methods&#x60; field is an array that allows multiple payment options to be defined. If this field is not explicitly set, all the payment methods are selected. For now, possible values are &#x60;card&#x60; and &#x60;sepa_debit&#x60;.
   * @return providerPaymentMethods
  **/
  @javax.annotation.Nullable
  public List<String> getProviderPaymentMethods() {
    return providerPaymentMethods;
  }


  public void setProviderPaymentMethods(List<String> providerPaymentMethods) {
    this.providerPaymentMethods = providerPaymentMethods;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CustomerBillingConfiguration customerBillingConfiguration = (CustomerBillingConfiguration) o;
    return Objects.equals(this.invoiceGracePeriod, customerBillingConfiguration.invoiceGracePeriod) &&
        Objects.equals(this.paymentProvider, customerBillingConfiguration.paymentProvider) &&
        Objects.equals(this.providerCustomerId, customerBillingConfiguration.providerCustomerId) &&
        Objects.equals(this.sync, customerBillingConfiguration.sync) &&
        Objects.equals(this.syncWithProvider, customerBillingConfiguration.syncWithProvider) &&
        Objects.equals(this.documentLocale, customerBillingConfiguration.documentLocale) &&
        Objects.equals(this.providerPaymentMethods, customerBillingConfiguration.providerPaymentMethods);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(invoiceGracePeriod, paymentProvider, providerCustomerId, sync, syncWithProvider, documentLocale, providerPaymentMethods);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CustomerBillingConfiguration {\n");
    sb.append("    invoiceGracePeriod: ").append(toIndentedString(invoiceGracePeriod)).append("\n");
    sb.append("    paymentProvider: ").append(toIndentedString(paymentProvider)).append("\n");
    sb.append("    providerCustomerId: ").append(toIndentedString(providerCustomerId)).append("\n");
    sb.append("    sync: ").append(toIndentedString(sync)).append("\n");
    sb.append("    syncWithProvider: ").append(toIndentedString(syncWithProvider)).append("\n");
    sb.append("    documentLocale: ").append(toIndentedString(documentLocale)).append("\n");
    sb.append("    providerPaymentMethods: ").append(toIndentedString(providerPaymentMethods)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("invoice_grace_period");
    openapiFields.add("payment_provider");
    openapiFields.add("provider_customer_id");
    openapiFields.add("sync");
    openapiFields.add("sync_with_provider");
    openapiFields.add("document_locale");
    openapiFields.add("provider_payment_methods");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to CustomerBillingConfiguration
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CustomerBillingConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CustomerBillingConfiguration is not found in the empty JSON string", CustomerBillingConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!CustomerBillingConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CustomerBillingConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("payment_provider") != null && !jsonObj.get("payment_provider").isJsonNull()) && !jsonObj.get("payment_provider").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `payment_provider` to be a primitive type in the JSON string but got `%s`", jsonObj.get("payment_provider").toString()));
      }
      if ((jsonObj.get("provider_customer_id") != null && !jsonObj.get("provider_customer_id").isJsonNull()) && !jsonObj.get("provider_customer_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provider_customer_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provider_customer_id").toString()));
      }
      if ((jsonObj.get("document_locale") != null && !jsonObj.get("document_locale").isJsonNull()) && !jsonObj.get("document_locale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `document_locale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("document_locale").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("provider_payment_methods") != null && !jsonObj.get("provider_payment_methods").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `provider_payment_methods` to be an array in the JSON string but got `%s`", jsonObj.get("provider_payment_methods").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CustomerBillingConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CustomerBillingConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CustomerBillingConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CustomerBillingConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<CustomerBillingConfiguration>() {
           @Override
           public void write(JsonWriter out, CustomerBillingConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CustomerBillingConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CustomerBillingConfiguration given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CustomerBillingConfiguration
  * @throws IOException if the JSON string is invalid with respect to CustomerBillingConfiguration
  */
  public static CustomerBillingConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CustomerBillingConfiguration.class);
  }

 /**
  * Convert an instance of CustomerBillingConfiguration to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

